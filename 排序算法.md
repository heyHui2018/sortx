##分类
###1.非线性时间比较类
* 交换排序——冒泡/快速
* 插入排序——插入/希尔
* 选择排序——选择/堆
* 归并排序——归并
###2.线性时间非比较类
* 计数/桶/基数

##复杂度
![复杂度](../../pic/复杂度.png)
* 稳定：若a在b前面且a=b,则排序后a仍在b前面
* 不稳定：若a在b前面且a=b,排序后a可能会在b后面

##冒泡排序
###1.基本思想
比较两个相邻的数，大数下沉，小数冒出。
###2.过程
* A.比较相邻的两个数，若后者较小则交换
* B.从前向后依次两两比较，最终最大数会被交换到最后
* C.对剩余元素重复上述步骤
![冒泡排序](../../pic/冒泡排序动图.gif)

##快速排序
###1.基本思想
根据选出的基数将数列分成两部分，分别进行排序。
###2.过程
* A.从数列中挑出一个基数
* B.遍历数列，比基数小的放在基数之前，大的放在基数之后
* C.针对两个子数列重复上述步骤
![快速排序](../../pic/快速排序动图.gif)

##插入排序
###1.基本思想
构建有序序列，遍历待排数列，在有序数列中找到相应位置并插入
###2.过程
* A.将第一个元素视为已排序列
* B.取下一元素，在已排序列中从后向前扫描
* C.若已排序列中的元素大于新元素，则将已排序列中的元素向后移
* D.重复步骤C直到找到小于或等于新元素的位置
* E.将新元素插入
* F.重复B-E
![简单插入排序](../../pic/简单插入排序动图.gif)
###3.分析
通常采用in-place排序（只需用到O(1)的额外空间），在从后向前扫描过程中，反复把已排序的元素逐步向后挪

##希尔排序
###1.基本思想
插入排序改进版，不同之处在于将整个待排序列分成若干个子序列进行直接插入排序，又称缩小增量排序
###2.过程
* A.设定步长，根据步长将数列分为若干组并进行排序(步长=4，则第一位和第五位为一组)
* B.缩小步长重复A直至步长=1
![希尔排序](../../pic/希尔排序动图.gif)
###3.分析
核心在于步长的设定

##选择排序
###1.基本思想及过程
在待排序数列中找到最小（大）元素，存放到排序序列的起始位置，然后继续寻找剩余的最小（大）值，放到已排序序列的末尾，以此类推。
![简单选择排序](../../pic/简单选择排序动图.gif)
###2.分析
最稳定排序算法之一，时间复杂度始终是O(n2)，唯一优点是不占用额外的内存空间

##堆排序
###1.基本思想
利用堆的数据结构(近似完全二叉树)，又同时满足堆的性质(子节点的键值或索引总是小于或等于其父节点)
###2.过程
* A.将待排序列（R1,R2,...,Rn）构建成大顶堆，此堆为初始的无序区
* B.将堆顶元素R[1]与最后一个元素交换，此时得到新无序区（R1,R2,...,Rn-1）和新有序区（Rn），且满足R[1,2...n-1]<=R[n]
* C.交换后需对原堆（R1,R2,...,Rn-1）进行调整，再将R[1]与无序区最后一个元素进行交换，得到新无序区（R1,R2,...,Rn-2）和新有序区（Rn-1，Rn）
* D.重复上述步骤
![堆排序](../../pic/堆排序动图.gif)

##归并排序
###1.基本思想
采用分治法，将已有序的子序列合并，即先对子序列排序，再使各子序列段间有序
###2.过程
* A.把长度为n的待排序列分成一分为二
* B.对子序列采用归并排序
* C.将两个排好序的子序列合并成一个有序序列
![归并排序](../../pic/归并排序动图.gif)
###3.分析
最稳定的排序算法之一，时间复杂度始终是O(nlogn)，代价是需要额外的内存空间

##计数排序
###1.基本思想
将输入的数据转化为键存储在一个新的数组中(适用于输入的数据是有确定范围的整数)
###2.过程
* A.找出待排序列中的最大值和最小值
* B.统计数列中值为i的出现次数，存入新数组的第i项
* C.遍历新数组
![计数排序](../pic/计数排序动图.gif)
###3.分析
稳定的排序算法，当输入的元素是n个0-k之间的整数时，时间复杂度是O(n+k),空间复杂度也是O(n+k)，排序速度快于任何比较排序算法

##桶排序
###1.基本思想
计数排序的升级版，利用了函数的映射关系，高效与否的关键在于映射函数。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序
（可使用别的排序方法，也可用递归方式继续使用桶排序）
###2.过程
* A.设置一个定量的数组作为空桶
* B.遍历待排序列，将其一一放到对应的桶中
* C.对每个非空桶进行排序
* D.从非空桶中拿出排好序的数据进行拼接
![桶排序](../../pic/桶排序图.gif)
###3.分析
最好情况下时间复杂度为O(n)，取决于各桶间数据进行排序的时间复杂度。显然桶分的越小，数据就越少，排序时间就越短，但消耗更多空间

##基数排序
###1.基本思想
按照低位先排序，然后收集，再按照次低位排序，再收集，以此类推直至最高位。
###2.过程
* A.取得数列中的最大数，并计算位数
* B.arr为原始数组，从最低位开始取每个位组成radix数组
* C.对radix进行计数排序
![基数排序](../../pic/基数排序动图.gif)
###3.分析
基数排序性能要比桶排序差